//
// Generated file, do not edit! Created by nedtool 4.6 from Messages/SIMCAN_Message.msg.
//

#ifndef _SIMCAN_MESSAGE_M_H_
#define _SIMCAN_MESSAGE_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
#include <list>
#include <string>
#include "SIMCAN_types.h"
	
	
   /**
	* Structure that represents a trace piece.
	*/
	struct TraceComponent{
		int moduleID;						/**< Module ID */
		int gateID;							/**< Gate ID to moduleID */
		std::list <reqNum_t> reqSequence;	/**< Requests sequence */
		
		
	   /**
		* Assignment operator
		* @param other Trace component
		*/
		TraceComponent& operator=(const TraceComponent& other);	
		
	   /**
		* Constructor
		* @param newModule Module ID
		* @param newGate Gate ID		
		*/
		TraceComponent (int newModule, int newGate); 
		
	   /**
		* Constructor
		* @param newModule Module ID
		* @param newGate Gate ID
		* @param newReq Request number		
		*/
		TraceComponent (int newModule, int newGate, reqNum_t newReq);		
	};
// }}

/**
 * Class generated from <tt>Messages/SIMCAN_Message.msg:50</tt> by nedtool.
 * <pre>
 * ///
 * /// SIMCAN Message Base definition
 * ///
 * message SIMCAN_Message extends cPacket
 * {
 *     @customize(true);
 * 
 *     unsigned int operation = -1;						// Operation type
 *     bool isResponse = false;							// Is a response message?
 *     bool remoteOperation = false;						// Is a remote operation?		
 * 
 *     int connectionId = -1;								// Connection ID (Used in remote operation between nodes)
 *     int commId = -1;									// Communication ID (Used to locate a communication with server)
 *     unsigned int sourceId = NULL_PROCESS_ID;			// ID from the source process
 * 
 *     unsigned int nextModuleIndex = -1;					// Array index destination module.				
 *     int result = 0;										// Operation result.
 * 
 *     abstract TraceComponent trace[];					// Message trace			
 * }
 * </pre>
 *
 * SIMCAN_Message_Base is only useful if it gets subclassed, and SIMCAN_Message is derived from it.
 * The minimum code to be written for SIMCAN_Message is the following:
 *
 * <pre>
 * class SIMCAN_Message : public SIMCAN_Message_Base
 * {
 *   private:
 *     void copy(const SIMCAN_Message& other) { ... }

 *   public:
 *     SIMCAN_Message(const char *name=NULL, int kind=0) : SIMCAN_Message_Base(name,kind) {}
 *     SIMCAN_Message(const SIMCAN_Message& other) : SIMCAN_Message_Base(other) {copy(other);}
 *     SIMCAN_Message& operator=(const SIMCAN_Message& other) {if (this==&other) return *this; SIMCAN_Message_Base::operator=(other); copy(other); return *this;}
 *     virtual SIMCAN_Message *dup() const {return new SIMCAN_Message(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SIMCAN_Message_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SIMCAN_Message);
 * </pre>
 */
class SIMCAN_Message_Base : public ::cPacket
{
  protected:
    unsigned int operation_var;
    bool isResponse_var;
    bool remoteOperation_var;
    int connectionId_var;
    int commId_var;
    unsigned int sourceId_var;
    unsigned int nextModuleIndex_var;
    int result_var;

  private:
    void copy(const SIMCAN_Message_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SIMCAN_Message_Base&);
    // make constructors protected to avoid instantiation
    SIMCAN_Message_Base(const char *name=NULL, int kind=0);
    SIMCAN_Message_Base(const SIMCAN_Message_Base& other);
    // make assignment operator protected to force the user override it
    SIMCAN_Message_Base& operator=(const SIMCAN_Message_Base& other);

  public:
    virtual ~SIMCAN_Message_Base();
    virtual SIMCAN_Message_Base *dup() const {throw cRuntimeError("You forgot to manually add a dup() function to class SIMCAN_Message");}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getOperation() const;
    virtual void setOperation(unsigned int operation);
    virtual bool getIsResponse() const;
    virtual void setIsResponse(bool isResponse);
    virtual bool getRemoteOperation() const;
    virtual void setRemoteOperation(bool remoteOperation);
    virtual int getConnectionId() const;
    virtual void setConnectionId(int connectionId);
    virtual int getCommId() const;
    virtual void setCommId(int commId);
    virtual unsigned int getSourceId() const;
    virtual void setSourceId(unsigned int sourceId);
    virtual unsigned int getNextModuleIndex() const;
    virtual void setNextModuleIndex(unsigned int nextModuleIndex);
    virtual int getResult() const;
    virtual void setResult(int result);
    virtual void setTraceArraySize(unsigned int size) = 0;
    virtual unsigned int getTraceArraySize() const = 0;
    virtual TraceComponent& getTrace(unsigned int k) = 0;
    virtual const TraceComponent& getTrace(unsigned int k) const {return const_cast<SIMCAN_Message_Base*>(this)->getTrace(k);}
    virtual void setTrace(unsigned int k, const TraceComponent& trace) = 0;
};


#endif // ifndef _SIMCAN_MESSAGE_M_H_

