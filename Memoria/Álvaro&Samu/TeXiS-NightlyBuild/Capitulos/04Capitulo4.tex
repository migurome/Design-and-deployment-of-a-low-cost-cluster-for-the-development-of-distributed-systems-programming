%---------------------------------------------------------------------
%
%                          Capítulo 4
%
%---------------------------------------------------------------------
\chapter{T\'ecnicas para la generaci\'on de mazmorras}

\begin{FraseCelebre}
\begin{Frase}
Infinito: Mayor que la cosa más grande que haya existido nunca, y más. Mucho mayor que eso, en realidad; verdadera y asombrosamente enorme, de un tamaño absolutamente pasmoso, algo para decir: "vaya, qué cosa tan inmensa". 
\end{Frase}
\begin{Fuente}
Douglas Adams Novelista y humorista inglés. 	
\end{Fuente}
\end{FraseCelebre}

%\begin{resumen}
%...
%\end{resumen}

\section{Idea inicial}
La idea inicial de este trabajo era investigar y desarrollar técnicas para automatizar diferentes partes o elementos de un videojuego mediante AGs, y, si fuese posible, utilizar una red neuronal como elemento que otorgue una nota o medida de calidad -fitness- a los individuos. La intención es que, mediante técnicas de programación evolutiva, se logre automatizar los procesos de desarrollo del mayor número de elementos posibles de un juego.\par

\section{Generaci\'on de mazmorras mediante algoritmos gen\'eticos}
\subsection{Introducci\'on}
Como se ha explicado anteriormente, se quieren generar mazmorras de forma automática utilizando AG. Con la descripción de mazmorra que hemos dado, la tarea principal es encontrar una implementación de cromosoma que describa correctamente toda la información relevante de una mazmorra, pero con la que además sea posible aplicar los operadores genéticos propios del AG.\par
Un individuo de nuestro AG es entonces una mazmorra completa, es decir, un conjunto de salas interconectadas.\par
Por lo tanto parece viable  que la representación para nuestro individuo sea un grafo que represente los elementos interconectados. Desde el punto de vista del AG, los grafos presentan ciertas ventajas: son fáciles de implementar, se pueden cortar y combinar con facilidad en poco tiempo y las mutaciones pueden consistir en añadir o quitar tanto nodos como aristas aleatorias.\par
Otras ventajas que tiene la implementación mediante grafos son la gran variedad de implementaciones disponibles y la facilidad para realizar combinaciones y mutaciones entre grafos.\par

\subsection{Decisiones de implementaci\'on}
Ya decidido que la representación de las mazmorras será un grafo, existen múltiples formas de implementarlo. Teniendo en cuenta las operaciones a realizar, las distintas implementaciones tendrán diferentes costes, tanto temporales como en espacio.\par
En nuestro caso comparamos tres implementaciones típicas, como se puede ver en \ref{fig:13}:\par
\begin{itemize}
\item \underline{Matriz de adyacencia}: Una matriz bidimensional de dimensiones NxN, donde N es el número total de nodos, en la que cada posición Mij tendrá valor true o false según exista o no arista entre los nodos i y j respectivamente.
\item \underline{Lista de aristas}: Se mantiene un array de Aristas, indicando los nodos Origen y Destino (simple nomenclatura, dado que el grafo no será dirigido).
\item \underline{Lista de adyacencia}: Similar a la matriz de adyacencia, pero en lugar de ser una matriz bidimensional, de cada nodo se guarda un conjunto de nodos adyacentes.
\end{itemize}
En primer lugar es necesario mencionar que todas estas implementaciones deben ir acompañadas de una lista con la información que guardan los nodos, en nuestro caso particular la información propia de cada sala (dimensiones, enemigos, etc).\par
Para justificar la toma de decisiones, es necesario entender cómo es cada implementación internamente, y cuáles son sus costes.\par

\figurahere{Bitmap/13}{width=1.5\textwidth}{fig:13}%
{Diferentes implementaciones del Grafo}

Los costes de las operaciones más utilizadas, en el caso peor, son:\par

\begin{table}[H]
{\setlength{\tabcolsep}{4pt}
\begin{tabular}{|l|l|l|l|}
\hline
\backslashbox{Operaciones}{Implementaci\'on} & L. Aristas & L. Adyacencia & M. Adyacencia \\
\hline
Hay arista en (i, j) & O(A) & O(log(G)) & O(1)\\
\hline
Grado(i) & O(A) & O(1) & O(N)\\
\hline
Insertar nodo & NA & O(1)* & O(N^2)$**$\\
\hline
Insertar arista & O(1)* & O(log(G)) & O(1)\\
\hline
Coste en espacio & O(A) & O(2A)*** & O(N^2)\\
\hline
\end{tabular}}
\caption{Costes implementaciones Grafo\\}
\end{table}
Leyenda: NA: No Aplicable; A = nº Aristas; N = nº Nodos; G = Grado del nodo `i'\\
**El coste de inserci\'on es constante (de promedio)\\
***Conlleva crear otra matriz mayor (puede optimizarse)\\
****Cada arista aparece dos veces, una en `i'\ y otra en `j'\\

Descartamos de forma casi inmediata la implementación de Lista de aristas por varias razones. En primer lugar, esa implementación conlleva que, o bien un nodo ejerce de origen y otro de destino para una arista en concreto, lo que dificulta la operación de saber si dos nodos son vecinos, ya que es necesario buscar en ambos extremos de la arista cada uno de los nodos, necesariamente recorriendo la lista (coste lineal en el nº de aristas), o bien se duplica la información, poniendo cada arista dos veces, pero intercambiando los nodos origen y destino. Otro de los inconvenientes de dicha implementación es que, dado un nodo en particular, no se puede saber de forma inmediata con cuántos nodos tiene arista, esto es, el grado del nodo.\par
Entre las implementaciones de Matriz de adyacencia y Lista de adyacencia debíamos decidir cual nos convenía más. \par
El principal problema de la Matriz de adyacencia es que implica crear una nueva matriz si se amplía el número de nodos del grafo; además, es lógico pensar que en operaciones que impliquen mezclar grafos será necesario copiar trozos de cada matriz, lo que tendría un coste promedio en tiempo de $N^2$. La única ventaja de la Matriz de adyacencia es que el coste de saber si dos nodos están conectados es constante, pero tiene muchas desventajas en  operaciones más complejas.\par
Por su parte, la Lista de adyacencia tiene costes logarítmicos en el grado de cada nodo en particular en los peores casos, lo cual no es demasiado, ya que los grafos no deberían ser demasiado densos en general. Además, por su propia estructura, mantiene la adyacencia de cada nodo de forma separada, lo que facilita dividir un grafo en dos, quitando de cada mitad los nodos vecinos que estuviesen en la otra.\par
Es importante mencionar que la operación Grado(i) tiene un peso especial, ya que, como se explicará más adelante, será una de las bases de la función de fitness del AG; esta función se utilizará con mucha frecuencia por lo que conviene que tenga un coste constante.\par
Por estos motivos decidimos usar la Lista de adyacencia como nuestra implementación de grafo. Para muestra, la figura \ref{fig:14} y la siguiente tabla:\par

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Nodo considerado & Lista de adyacencia\\
\hline
1 & 2 y 3\\
\hline
2 & 1, 3 y 4\\
\hline
3 & 1, 2 y 4\\
\hline
4 & 2 y 3\\
\hline
\end{tabular}
\caption{Lista de adyacencia nodos\\}
\end{center}
\end{table}

\figurahere{Bitmap/14}{width=.6\textwidth}{fig:14}%
{Adyacencia nodos}

\subsection{Evaluación de las mazmorras: Visión general}
El grafo será entonces el esqueleto que determina cómo están unidas las salas. El segundo paso consiste en rellenar ese esqueleto con los elementos propios del juego como puertas que unen las salas, enemigos, cofres y demás elementos decorativos. Esto se llevaría a cabo tras haber generado un grafo suficientemente bueno.\par
Sin embargo, nos presentaban un problema fundamental para el correcto funcionamiento del AG, la función de evaluación, esto es, ¿cuán bueno es un grafo?\par
Debido a la complejidad de la implementación, tuvimos que descartar la idea inicial de que la función de evaluación la realizara una red neuronal previamente entrenada con ejemplos a mano. Optamos entonces por crear una función de fitness que tuviese un funcionamiento similar, evaluando cada grafo en función de diversos aspectos clave, cada uno de ellos con un peso que podríamos variar hasta dar con una ponderación adecuada. Ahora bien, ¿cuáles son estos aspectos clave?\par
Ésta era la siguiente pregunta a responder. En primer lugar, nos dimos cuenta de que debido a la aleatoriedad de los grafos, éstos podrían tener varias CCs diferentes, e igual una de ellas era suficiente para nosotros como mazmorra completa. Así pues, la primera decisión que tomamos fue que la nota o ``medida de calidad''\ de un grafo completo sería la mejor nota de cualquiera de sus CCs. Quedaba entonces por determinar los aspectos clave para evaluar las CCs.\par
El objetivo era generar una mazmorra que, sin ser excesivamente grande, resultase divertida. Para este punto, decidimos que la mazmorra tuviese ciertas salas clave, en concreto, una sala inicial, de la que parte el jugador, una sala final, a la que debe llegar, y una sala con una llave, que permitirá al jugador pasar al siguiente nivel desde la sala final. De esta forma, se proporciona un objetivo al jugador para explorar la mazmorra.\par
Durante dicha exploración, el jugador debería encontrarse obstáculos que superar (enemigos) y recompensas por haber explorado (cofres). Conseguimos esto sencillamente generando para cada sala un número aleatorio de estos dos elementos. Sin embargo, este enfoque presentaba unos problemas que tuvimos que resolver y se explicarán más adelante.\par
Tras un profundo análisis, consideramos que había 5 puntos importantes que eran interesantes para nuestros mapas o mazmorras. \par
\begin{itemize}
\item \textbf{La distancia entre las salas clave:} si las tres salas clave están demasiado juntas, el jugador no tendrá la necesidad de explorar la mazmorra.
\item \textbf{El tamaño de la mazmorra:} si la mazmorra es muy pequeña resultaría aburrida; por el contrario, si es demasiado grande, podría resultar injugable.
\item \textbf{La conexión entre salas:} si las salas están demasiado interconectadas, al jugador le cuesta mucho más crear un mapa mental de la mazmorra.
\item \textbf{La dispersión de enemigos y cofres:} al ser situados de forma aleatoria, podría resultar que en una zona de la mazmorra se acumulasen muchos enemigos o cofres.
\item \textbf{El tamaño de las salas:} se favorece que las salas tengan una forma rectangular (apaisada), de manera que representarlas en una pantalla sea m\'as estético. Este parámetro es el menos relevante.
\end{itemize}

\subsection{Evaluación de las mazmorras: Detalle}
A continuación explicamos cómo valoramos cada uno de esos aspectos.\par
\subsubsection{Distancia entre salas clave}
El recorrido natural del jugador debería ser ir desde la sala inicial hasta la que contenga la llave, y luego encontrar la sala final para pasar al siguiente nivel. Por este motivo, decidimos \textbf{maximizar} la distancia (en salas o nodos) desde el origen hasta la sala de la llave y desde la sala de la llave hasta la sala final. Para el cálculo de la distancia, realizamos un recorrido en anchura (BFS) sobre el grafo. Para que una CC pueda puntuar en este aspecto, es necesario que contenga las tres salas clave. Favorecer mazmorras que solo tuviesen dos de ellas podría desembocar en individuos a los que les faltase una de las salas clave, lo cual no es permisible.\par


	\[DistanciaSalasClave = distancia(SalaInicio, SalaLlave) +\]\[+ distancia(SalaLlave, SalaFin)\]\par

\subsubsection{Tamaño de la mazmorra}
El tamaño de la mazmorra no es más que el número de salas que tiene la CC. Determinar si este era un aspecto que debíamos maximizar o minimizar no fue sencillo. Si maximizamos, corríamos el riesgo de generar mazmorras demasiado grandes y si minimizamos, sucedería lo contrario. Decidimos que lo mejor sería \textbf{minimizar} este aspecto, y en combinación con la distancia entre salas clave, se produciría un ``tira y afloja''\ en el que un aspecto favorecería mazmorras con muchas salas, mientras que el otro potenciaría aquellas más pequeñas. Si estos dos parámetros se ajustaban correctamente, podríamos generar mazmorras con un número adecuado de salas (entre 15 y 30, según nuestro criterio).\par

\subsubsection{Conexión entre salas}
Para evitar mazmorras demasiado complejas debíamos \textbf{minimizar} la interconexión entre salas. A \textit{priori} puede parecer que minimizar este aspecto conllevaría favorecer aquellas mazmorras que tuviesen pocas salas, pero al valorar la distancia entre salas clave como algo positivo lo que este factor favorece es la generación de mazmorras con varias salas interconectadas, pero de forma mínima \ref{fig:15}. \par

\figurahere{Bitmap/15}{width=1\textwidth}{fig:15}%
{Conexiones entre salas}

La forma de minimizar la interconexión es penalizar aquellas CCs en donde las salas tengan demasiadas entradas. En otras palabras, se pretende minimizar el grado de los nodos del grafo.\par

	\[MediaGrado = \frac{\sum\limits_{i=1}^{n}grado(i)}{n}
\]

Donde \textit{n} es el número de salas que tiene la CC y \textit{grado(i)} es el número de aristas que tiene la sala \textit{i}.\par

\subsubsection{Dispersión de enemigos y cofres}
Este parámetro sin duda debía ser maximizado ya que lo que se buscaba era que estos elementos del juego estuviesen muy repartidos. Para un elemento del juego, por ejemplo cofres, el parámetro de dispersión se establece como la distancia media (en salas) que separa a cada cofre del resto. Esta distancia se calcula para cada cofre de la CC y luego se realiza la media total. Más formalmente:\par

	\[Dispersion(e) = \frac{\sum\limits_{i=1}^{n_e}\frac{\sum\limits_{k=1}^{n_e}distancia(i, k)}{n-1}}{n}
\]

Donde \textit{e} es un elemento del juego (enemigos o cofres) y $n_e$ es la cantidad de dicho elemento en la CC. La función \textit{distancia(i, k)} devuelve la distancia en salas entre el elemento \textit{i} y el elemento \textit{k}, si ambos están dentro de la misma sala la función vale 0.\par

\subsubsection{Tama\'no de las salas}
Para favorecer las salas de forma apaisada, se debía \textbf{maximizar} el ratio entre ancho y alto de las salas. Para ello, se calcula la media de ancho y alto de todas las salas de la CC. Luego se calcula el \textit{ratio}, simplemente dividiendo estos dos valores. Por último, se le resta 1. Si el \textit{ratio} entre ancho y alto de una CC es menor que 1, implica que, de media, sus salas son más altas que anchas, luego este parámetro será negativo y penalizará en la función de fitness. De forma contraria, si el ratio es mayor que 1, el valor sumará. Si es igual a 1, es decir, salas normalmente cuadradas, el parámetro no penaliza, pero tampoco suma al fitness.\par

	\[RatioSalas = \frac{mediaAncho}{mediaAlto} - 1
\]

\subsubsection{La funci\'on de fitness}
La función que determinaría entonces cuán buena es una mazmorra sería la que sigue:\par

\begin{fleqn}
	\[Fitness = Maximizado - Minimizado
\]

	\[Maximizado = DistanciaSalasClave + Dispersion(cofres) +\]\[+ Dispersion(enemigos) + RatioSalas
\]

	\[Minimizado = NumeroSalas\ast0.4 + MediaGrado
\]
\end{fleqn}

Multiplicamos por 0.4 el número de salas de la CC para que evitar que se penalicen de más las mazmorras grandes, ya que tras algunas pruebas, restar el número directamente provocaba que las mazmorras resultantes fueran demasiado pequeñas.\par

\subsection{Operadores del Algoritmo Gen\'etico}
Ya hemos determinado cuál es la estructura de los individuos dentro del AG, así como la forma de evaluar cada uno de ellos. Falta entonces explicar otro de los aspectos fundamentales de la programación evolutiva: los operadores de selección, cruce y mutación.\par
Como ya se ha explicado anteriormente, variando entre diferentes métodos se modifica la forma en la que una población de individuos evoluciona. En concreto, nosotros decidimos implementar y probar las posibles combinaciones de los siguientes métodos.\par

\subsubsection{M\'etodos de selecci\'on}
Con distintos operadores de selección, se determina qué individuos pasarán a la fase de cruce, es decir, se eligen los individuos que podrían ser progenitores de nuevos individuos que conformarán la siguiente generación. Puede parecer lógico optar por un método de selección que siempre elige a los mejores individuos de cada generación, sin embargo, al hacer esto se puede estar reduciendo significativamente el espacio de soluciones posibles que el AE pueda alcanzar. En ocasiones puede suceder que la combinación entre un buen individuo y otro no tan bueno ocasione la creación de un nuevo individuo que supere al mejor individuo obtenido.\par
Distintos métodos de selección afectan de forma diferente a las poblaciones que se obtienen. Un método de selección que favorezca mucho a los mejores individuos provoca un aumento en la presión selectiva y a su vez se puede producir una evolución en avalancha o una convergencia prematura a causa de la falta de diversidad.\par
La presión selectiva se define como la aptitud máxima entre la aptitud media de una población.\par
Si la presión selectiva es muy alta, se pueden producir superindividuos que reducen el espacio de búsqueda del problema, si es muy baja, es indicativo de una falta de diversidad en la población. Lo ideal, es que la presión selectiva sea baja durante las primeras generaciones, y vaya aumentando conforme los individuos evolucionan.\par
Dicho esto, los operadores probados en la generación de mapas han sido:\par
\begin{itemize}
\item Selección por Ruleta: los individuos son seleccionados de forma proporcional a su aptitud. En un segmento de longitud 1, se divide de forma que a los individuos mejor adaptados les corresponde mayor porcentaje. 
\item Selección Estocástica: Mediante este método un individuo puede ser seleccionado múltiples veces, así como no ser seleccionado ninguna.
\item Selección por Torneo: Se seleccionan individuos en grupos de 3 y se van escogiendo los que mejor adaptación tengan, hasta completar la población.
\item Selección por Ranking: Se ordena en orden decreciente a los individuos según su fitness o adaptación. 
\end{itemize}
\subsubsection{M\'etodos de cruce}
En el caso particular de los grafos, es difícil aplicar operadores de cruce complejos que realmente aporten algo nuevo en la generación de nuevos individuos. Por el momento, hemos probado con:\par
\begin{itemize}
\item Cruce monopunto: se elige un número aleatorio entre 1 y N-2, siendo N el número total de nodos del grafo. Esto genera dos subgrafos diferentes que serán combinados con los subgrafos del otro progenitor.\par
\figurahere{Bitmap/16}{width=1.1\textwidth}{fig:16}%
{Cortes subgrafos}
Como se ve en la figura \ref{fig:16}, los puntos de corte de los progenitores pueden ser distintos. Al cortar, se generan dos subgrafos, que serán idénticos al grafo original, pero del cual se ha eliminado una parte de los nodos, y las aristas que conectan con dichos nodos.\par
Estos subgrafos se generan siguiendo el orden de los índices. Los mayores del índice de corte serán un subgrafo y los menores, otro.\par
Una vez obtenidos estos subgrafos, se combinan los subgrafos obtenidos de A, con los obtenidos de B, consiguiendo de esta forma nuevos individuos.\par
\figurahere{Bitmap/17}{width=1.1\textwidth}{fig:17}%
{Unión subgrafos}
Sin embargo, no es suficiente con unir los subgrafos de A y B; es necesario que entre estos subgrafos se hagan nuevas conexiones, sino se perderían aristas en cada cruce, consiguiendo eventualmente grafos totalmente inconexos. \par
Para evitarlo, una vez unidos los subgrafos en uno solo, se elige un conjunto pequeño de las posibles aristas entre los nodos del subgrafo A y los de B y se añaden al nuevo grafo. Una vez se han añadido estas aristas aleatorias, se reescriben los índices para que el rango sea de nuevo de  0 a N-1 \ref{fig:17}.\par
\item Cruce multipunto: el cruce multipunto se basa en varios cortes monopunto. Se eligen varios puntos de corte, y se combinan los diferentes subgrafos de A y B para conseguir los nuevos individuos.
\end{itemize}
\subsubsection{M\'etodos de mutaci\'on}
De manera eventual e intentando imitar el fenómeno de la mutación aleatoria que sucede de forma natural, algunos individuos pueden modificar su estructura interna sin necesidad de combinarlo con otros. Éste es el operador de mutación.\par
Hasta el momento, tenemos cuatro implementaciones de mutación para los grafos: \par
\begin{itemize}
\item Mutación de arista: se añade o se borra (50\% - 50\%) una arista aleatoria \ref{fig:18}.

\figurahere{Bitmap/18}{width=1\textwidth}{fig:18}%
{Mutaci\'on de arista}

\item Mutación de nodo \ref{fig:19}: se añade o se borra (50\% - 50\%) un nodo aleatorio.

\figurahere{Bitmap/19}{width=1\textwidth}{fig:19}%
{Mutaci\'on de nodo}

\item Mutación de sala: Se mueve de sitio una de las salas clave (inicio, llave o fin) de un nodo a otro \ref{fig:20}.

\figurahere{Bitmap/20}{width=1\textwidth}{fig:20}%
{Mutaci\'on de sala}

\item Mutación combinada: una mutación que combina las 3 anteriores como una sola.\par
\end{itemize}
\subsection{La implementaci\'on en detalle}
Una vez vistos los conceptos teóricos del cromosoma, es necesario explicar cómo será internamente un individuo del AG en lenguaje C++.\par
Para empezar, hemos decidido abstraer el concepto de Grafo del concepto Cromosoma. En lugar de que el Cromosoma en sí contenga los elementos propios de un grafo, hemos optado por encapsular el Grafo dentro del Cromosoma. \par
Aun así, el Cromosoma mantiene las operaciones propias de un individuo: función de evaluación, control del bloating, guarda parámetros de adaptación, acumulada, etc.\par
La función de evaluación se basa en realidad en pedir toda la información necesaria al Grafo que compone su genotipo, y realizar los cálculos en base a ella.\par
Por su parte, el Grafo está construido según lo explicado anteriormente, con algunos pequeños detalles. Se mantiene una tabla hash donde se asocia un identificador de nodo \textcolor{CornflowerBlue}{unsigned int} con su información asociada (tamaño de sala, nº de enemigos) Por otro lado, otra tabla hash asocia un identificador de nodo i con un conjunto que indica qué nodos son adyacentes a \textit{i}. \par
Los atributos de un Grafo son entonces:\par
\textcolor{BlueGreen}{std::unordered\_map}\textless \textcolor{CornflowerBlue}{unsigned int}, \textcolor{CornflowerBlue}{std::set\textlessunsigned int\textgreater}\textgreater \_ady;\par
\textcolor{BlueGreen}{std::unordered\_map}\textless\textcolor{CornflowerBlue}{unsigned int} N \textgreater \_nodos;\par
Los Grafos son construidos de forma aleatoria en base a 3 parámetros clave:\par
\begin{itemize}
\item Número mínimo de nodos
\item Número máximo de nodos
\item Densidad de aristas del grafo
\end{itemize}
\textcolor{BlueGreen}{Grafo \textless N \textgreater }(\textcolor{CornflowerBlue}{unsigned int} minNodos, \textcolor{CornflowerBlue}{unsigned int} maxNodos, \textcolor{CornflowerBlue}{double} densidad);\par
Cabe destacar que hemos implementado la clase Grafo de forma genérica, pudiendo abstraer la implementación del Grafo de la de Nodo, dado que el Grafo no necesita conocer ninguna información asociada a los nodos más allá de la adyacencia. Los Grafos son una estructura de datos muy común en el desarrollo de videojuegos, y en nuestro caso representan una mazmorra, pero pueden ser utilizados como representación de otros elementos de juego, pudiendo ser combinados y mutados de forma igual o similar.\par
Algunas operaciones son necesarias para cualquier grafo, como la posibilidad de añadir nuevos nodos o crear una arista entre dos nodos.\par
\textcolor{BlueGreen}{void} anadeNodo(\textcolor{CornflowerBlue}{N} nodo, \textcolor{CornflowerBlue}{int} id = -1);\par
\textcolor{BlueGreen}{bool} anadeArista(\textcolor{CornflowerBlue}{unsigned int} v, \textcolor{CornflowerBlue}{unsigned int} w);\par
El método \emph{anadeNodo} puede opcionalmente recibir el identificador del nodo a añadir (útil si se quieren cruzar dos Grafos con identificadores repetidos), aunque el identificador por defecto será el número de nodos del Grafo en el momento de la llamada. \par
Más importantes son los métodos específicos de nuestra implementación y de los  que se ha hablado anteriormente. Entre ellos se encuentra el método:\par
\textcolor{BlueGreen}{unsigned int} getGradoNodo(\textcolor{CornflowerBlue}{unsigned int} v);
Este método recibe un identificador de nodo y, si dicho nodo se encuentra en el Grafo, devuelve con cuántos nodos está conectado (grado del nodo). Dentro de este método, se busca el nodo en la tabla de adyacencia y se devuelve el tamaño del conjunto asociado, ambas operaciones de coste constante (en promedio).\par
\textcolor{BlueGreen}{std::vector \textless Grafo \textless N \textgreater \ \textgreater} divideGrafo(\textcolor{CornflowerBlue}{unsigned int} v);\par
\textcolor{BrickRed}{static} \textcolor{BlueGreen}{Grafo\textless N \textgreater} unirGrafo(\textcolor{CornflowerBlue}{Grafo \textless N \textgreater} a, \textcolor{CornflowerBlue}{Grafo \textless N \textgreater} b);\par
\textcolor{BlueGreen}{std::vector\textless Grafo \textless N \textgreater \ \textgreater} divideEnGrafos(\textcolor{CornflowerBlue}{unsigned int} n);\par
\textcolor{BrickRed}{static} \textcolor{BlueGreen}{Grafo\textless N \textgreater} unirGrafos(\textcolor{CornflowerBlue}{std::vector\textless Grafo \textless N \textgreater \ \textgreater} subs);\par
El método \emph{divideGrafo} recibe un identificador de nodo, que será el punto por el cual se dividirá el Grafo. De está forma, todos los nodos anteriores a él (inclusive) formarán el primer subgrafo, y los posteriores el segundo. Las aristas que hubiese entre ambos subgrafos son eliminadas.
Por su parte, el método \emph{unirGrafo} realiza la operación contraria, crea un Grafo en base a dos subgrafos, y añade aristas arbitrariamente entre ambos.
Los métodos \emph{divideEnGrafos} y \emph{unirGrafos} no son más que múltiples llamadas a los dos métodos anteriores respectivamente.
Por último, implementamos un método que permitiese conocer las CCs de un grafo, necesarias en la función de fitness, pues cada una de ellas se evalúa de forma independiente pese a formar parte del mismo Grafo.\par
\textcolor{BlueGreen}{std::vector\textless ComponenteConexa \textless N \textgreater \ \textgreater} getComponentesConexas() const;\par
En un primer momento, decidimos que la clase \emph{ComponenteConexa \textless N \textgreater} (la cual hereda de Grafo) nos podía permitir extender las operaciones que tenían los Grafos, como por ejemplo saber cuántos ciclos presentaba, sabiendo que en ellas no existen nodos inconexos unos de otros.
Sin embargo, como se explicó anteriormente, está es una operación compleja y muy costosa en tiempo, así que a efectos prácticos, las CCs son iguales que los Grafos, pero con la garantía de que todos los nodos están conectados.
Dentro del repositorio del proyecto se pueden encontrar más métodos, pero estos son los más relevantes.
\subsection{Individuos obtenidos}
A continuación se muestran ejemplos de mazmorras obtenidas con estos parámetros:
\figurahere{Bitmap/21}{width=1\textwidth}{fig:21}%
{Ejemplo de mazmorra 1}
\begin{itemize}
\item Las salas en color turquesa son las que forman parte de la CC seleccionada como mejor. 
\item Las salas coloreadas de un azul más oscuro son  aquellas que no pertenecen a la CC seleccionada. 
\item La sala verde es la Inicial, la naranja la de la Llave y la roja la Final.
\item Las aristas que unen los nodos (salas) están representadas mediante una línea morada.
\item Los números en color negro representan la enumeración de la sala.
\item Los números en rojo representan los enemigos dentro de esa sala.
\item Los números verdes identifican los cofres.
\item Los números azules identifican las dimensiones de la sala.
\end{itemize}
\figurahere{Bitmap/22}{width=1\textwidth}{fig:22}%
{Ejemplo de mazmorra 2}
Como se observa, las mazmorras son bastante buenas, ya que tienen el número de salas adecuado (entre 15 y 30) y  no están demasiado interconectadas. Por tanto, en vista a los resultados empíricos llevados a cabo, podemos suponer que la función de fitness es lo suficientemente adecuada.
Estos individuos han sido obtenidos tras varias horas de pruebas de parámetros del AG. El tiempo de generación de individuos con un fitness aceptable (como los mostrados), está entre 1 y 3 minutos, un tiempo que consideramos aceptable como tiempo de carga de contenido en la ejecución del juego.\par
\section{Interfaz de usuario}
Al elegir como lenguaje de desarrollo C++, tuvimos que superar el problema de la  representación gráfica. Este problema nos surgió en el desarrollo de las mazmorras. Decidimos utilizar la misma librería gráfica con la que posteriormente desarrollaríamos el juego:  SFML. 
Para poder extraer conclusiones de la ejecución de los distintos AGs era necesario crear algo similar a un visor de gráficas de función. Para visualizar las gráficas de evolución y analizar la convergencia, se ha implementado un visor de funciones \ref{fig:24} -similar a la librería de java jMathPlot- con algunas de las operaciones que necesitábamos. A saber:
\begin{itemize}
\item Poder representar AGs con diversas generaciones. (Eje X de tamaño variable)
\item Poder representar más de una línea de valores en el Eje Y (poder ver el fitness del mejor individuo global a la vez que la media o el mejor por cada generación).
\item Poder asignar un nombre a cada línea de valores (Leyenda).
\end{itemize}
\figurahere{Bitmap/24}{width=.9\textwidth}{fig:24}%
{Visor de funciones}
\figurahere{Bitmap/25}{width=1\textwidth}{fig:25}%
{Visor de mazmorras}
Este visor de funciones \ref{fig:24} nos ayudó mucho en lo respectivo a los AGs, sin embargo, aún resultaba complicado ver qué tipo de mazmorras se generaban.  En las gráficas se puede apreciar como va evolucionando el fitness de la mazmorra con el paso de las iteraciones. Este valor se obtiene de la función de fitness mencionada anteriormente.\par
Por tanto, decidimos implementar un visor de grafos \ref{fig:25} que incluyese de forma clara la información de las salas. Por último, queríamos poder ver cómo se verían las salas definitivamente en el juego, así que decidimos crear también un visor de salas \ref{fig:26}.
\figurahere{Bitmap/26}{width=1\textwidth}{fig:26}%
{Visor de salas}
Con algunos sprites provisionales, podíamos hacernos a la idea de la forma de las salas y su dificultad. Tanto los enemigos como los cofres son colocados de forma aleatoria, pues su posición no está indicada ni es relevante en está fase del desarrollo.\par
De esta forma, con una GUI sencilla podíamos ver toda la información de una ejecución completa del AG.\par

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
