%---------------------------------------------------------------------
%
%                          Capítulo 2
%
%---------------------------------------------------------------------

\chapter{Desarrollo del software}

\begin{FraseCelebre}
\begin{Frase}
Me gusta y me fascina el trabajo. Podría estar sentado horas y horas mirando a otros cómo trabajan.
\end{Frase}
\begin{Fuente}
Jerome K. Jerome, Humorista inglés.
\end{Fuente}
\end{FraseCelebre}

%\begin{resumen}
%...
%\end{resumen}

Para analizar el estado del arte de este proyecto, tenemos que tener en cuenta 3 aspectos fundamentales:\par
\begin{itemize}
\item La generación procedural de contenido para videojuegos.
\item La generación de contenido para videojuegos mediante algoritmos evolutivos.
\item Las diferentes implementaciones de IAs existentes.
\end{itemize}



Generación procedural es el método de creación de contenidos a través de algoritmos, en oposición a un método de creación manual, y se aplica tanto en simulaciones gráficas por computadora como en videojuegos, instalaciones, programación y en música. Los fractales son un ejemplo de animación mediante generación procedural: funciones matemáticas gráficas repetidas hasta el infinito. El sonido digital también se puede generar de forma procedural, un uso que se ha desarrollado mucho para la música electrónica.\par
En videojuegos e instalaciones la generación procedural se utiliza en función de que el contenido se genere en la computadora que los contiene, en tiempo real, y no de manera previa y renderizado en paquetes gráficos predefinidos. Se utiliza principalmente para la generación de ambientes y mapas, aunque también se aplica para IA y jugabilidad. Se utiliza para generar de manera rápida y detallada espacios infinitos y patrones de singularidad en objetos, simulaciones y personajes. También se utiliza para la creación de sistemas de partículas para agua, fuego y gases; o para generar un sinfín de actores digitales únicos y diferentes como reemplazo de extras. Sin embargo, no se suele utilizar para el contenido final, el cual en general se muestra ya preestablecido. En \citep*{Gamasutra} se muestra una técnica para generar mazmorras aleatorias. Los pasos para ello son:\par

\figurahere{Bitmap/1}{width=.7\textwidth}{fig:1}%
{Escenario creado mediante Generación Procedural}

\begin{itemize}
\item Generar una serie de salas con una determinada anchura y altura y colocarlas aleatoriamente dentro de un círculo.
\item Separar las diferentes salas aplicando físicas de colisión, hasta que no se superpongan.
\item Después, para escoger qué salas son las principales, se tendrán en cuenta aquellas que estén por encima de 1.25 en el ratio ancho/alto.
\item Tomar los puntos medios de las salas principales y aplicarles el Procedimiento de Delaunay \citep*{Delaunay} para obtener un grafo a partir de los triángulos obtenidos.
\item A partir del grafo, se debe obtener el árbol de expansión mínimo \citep*{Krusk}. Esto hará que todas las habitaciones principales sean accesibles, pero que no estén conectadas directamente.
\item Finalmente, se añaden los pasillos a la mazmorra. Si los nodos están cerca horizontalmente, se añade una línea horizontal. Lo mismo para los nodos cercanos verticalmente. Si no es así, se añaden dos líneas que formen una L.
\end{itemize}
 
Existen proyectos que, mediante gramáticas evolutivas, generan historias de fondo que aportan consistencia a la experiencia de juego, con la intención de evitar que éstas deban ser ideadas por desarrolladores de forma manual \citep*{Garcia}.\par
Existen herramientas que permiten utilizar algoritmos genéticos para generar mazmorras en base a unos parámetros de diseño \citep*{Font}, que tienen que venir definidos previamente.\par
En este sentido cabe reseñar el ejemplo explicado en \citep*{Toguelius},  que cuenta cómo se pueden desarrollar funciones heurísticas que miden propiedades de los mapas y comprueban si afectan a la experiencia de juego. Se diseñaron dos representaciones diferentes de mapas, una para un juego de estrategia genérico y otro para el videojuego Starcraft. Mediante este método se puede automatizar completamente la generación de mapas o como herramienta de apoyo para diseñadores humanos.\par
Otro ejemplo más es el referido en \citep*{Perez} que analiza 3 subcomponentes diferentes en el proceso de generación de mapas y propone soluciones a todos ellos. Los mapas se representan mediante 2 conceptos distintos, la geometría y la disposición del contenido. La geometría se lleva a cabo tanto en el exterior como en el interior conectando segmentos de mapas pre-hechos para formar mapas más grandes y completos. La disposición del contenido a través del mapa se determina mediante el uso de características de la geometría como el uso de una Red de Producción de Patrones de Composición. Por último están las preferencias del jugador para diseño del contenido, que se capturan y se utilizan en un marco de sistema recomendador. Todas las soluciones se combinan y se prueban en el videojuego de acción y disparos \textit{Angry Bots} \citep*{Bots} y se evalúan en un experimento a gran escala.\par
Existe un precedente de uso de AGs para evolucionar el comportamiento de los bots -enemigos jugadores controlados por el ordenador- en un videojuego más o menos actual, concretamente el \textit{Unreal Tournament 2004} \citep*{Bullen}.Los resultados demostraron una mejora considerable en el rendimiento de los bots evolucionados, con respecto al grupo de control.\par
En otra ocasión se usó programación genética  para la evolución de estrategias defensivas. En \citep{Jackson} se utiliza la programación genética para evolucionar estrategias en un simple juego que emula los invasores del espacio \ref{fig:2}. \par
\figurahere{Bitmap/2}{width=.7\textwidth}{fig:2}%
{Emulador de \textsl{Space Invaders}}
Para la función de evaluación se realizaron un conjunto de pruebas. En cada una, el defensor se colocaba en la parte inferior del mapa, mientras que los oponentes se colocaban en cualquiera de las filas superiores, desplazándose inicialmente en una dirección elegida al azar. Después, irían descendiendo de izquierda a derecha, bajando cuando llegasen a los límites laterales del tablero y lanzando bombas de vez en cuando. Se utilizaron los operadores genéticos más comunes.\par
Se demostró que mediante programación genética es posible desarrollar estrategias de defensa para hacer frente a juegos de una determinada dificultad. Esas estrategias incorporan muchos de los aspectos de la evasión, la búsqueda y la conducta de orientación que se encuentran en jugadores humanos.\par

Se define un conjunto de elementos terminales:\par

	\[T = {\{IZQUIERDA, DERECHA, FUEGO, DIST_Y, DIST_X\}}
\]
y un conjunto de funciones:\par

	\[O = {\{IF, EQ, PROGN2, PROGN3\}}
\]

Después de un proceso evolutivo se obtienen soluciones representadas de la siguiente forma:\par

\begin{flushleft}

	\[(IF (EQ (DIST_Y DIST_X))\]\par

\end{flushleft}


	\[\hspace{2cm(PROGN3 (FUEGO IZQUIERDA DIST_X))}\]\par
	\[\hspace{2cm(PROGN2 (IZQUIERDA IZQUIERDA))})\]\par
	
El significado de esa expresión es el siguiente: \par

\begin{itemize}
\item Si la distancia en Y es igual que la distancia en X, se ejecuta\par $PROGN3 (FUEGO\;IZQUIERDA\;DIST_X)$, que disparar\'a, avanzar\'a a la izquierda y calcular\'a la distancia horizontal hasta el defensor.
\item Si no es igual, se ejecuta $PROGN2 (IZQUIERDA\;IZQUIERDA)$, que avanzar\'a dos casillas hacia la izquierda.
\end{itemize}

Por otro lado, combinando el uso de algoritmos genéticos con Grafos tenemos el problema del coloreamiento mínimo de un grafo \citep*{Grafo}. Se han de utilizar el menor número de colores cumpliéndose la restricción siguiente: Dos nodos adyacentes no pueden tener el mismo color.\par
Se trata de un problema NP-completo. No hay un método que asegure que se va a obtener el coloreamiento óptimo para todos los tipos de grafos que se presenten. Esto se debe a que con sólo añadir alguna arista o nodo a un grafo dado, la solución cambia radicalmente.\par
En este problema, un individuo es una permutación de todos los nodos del grafo. La población de individuos se selecciona mediante el método de la Ruleta. Dada la facilidad para evaluar si hay que añadir un color extra o no, los individuos suelen ser bastante buenos. \par
Dada una permutación de nodos de un grafo, hay que colorear dicho grafo recorriendo en orden los nodos, asignándoles a cada uno el primer color que puede tener cumpliendo las restricciones. La función de Fitness busca obtener el mínimo número de colores necesarios para el coloreamiento completo del grafo. Para la reproducción de los individuos se puede utilizar cruce monopunto, mientras que la mutación se puede cambiar de orden dos nodos del individuo.\par


En un videojuego, se define la inteligencia artificial -IA- como la simulación de inteligencia -comportamiento, modo de actuar, etc.- de los PNJs y que normalmente incluirá algo relacionado con los siguientes aspectos:\par
\begin{itemize}
\item Conseguir comportamientos muy básicos en los PNJs -coger un elemento, golpear, etc…-
\item Moverse a través de unos escenarios en los que pueden aparecer obstáculos.
\item Tomar decisiones para saber qué acciones realizar y en qué orden.
\end{itemize}
Hay diversas maneras de implementación de estas IAs \citep*{Alcala}:\par
\begin{itemize}
\item Algoritmos minimax: se utiliza normalmente en juegos de tablero como el Ajedrez o las damas. Está basado en la prueba de todas las posibilidades de jugada de cada jugador. Se puede optimizar utilizando la poda alfa-beta.
\item Algoritmos de búsqueda de camino (Dijkstra, A*…). Búsqueda del camino más corto para llegar de un punto A a otro punto B. A* es una combinación de recorridos de tipo \textit{primero en anchura} con \textit{primero en profundidad} y garantiza encontrar siempre el camino óptimo. Dijkstra, por su parte, determina en un grafo valorado el camino más corto para llegar desde un vértice a todos los demás del grafo.
\item Agentes inteligentes: se aplica cuando los PNJs perciben mediante sensores la existencia de algún elemento extraño en el entorno -pared, esquina donde hay que girar, un enemigo- y actúa consecuentemente -dándose la vuelta, girando, pasando a modo ataque- con la mejor acción posible, gracias a unos \textit{actuadores} que le indican cómo debe hacerlo. Dos tipos:\par
\begin{itemize}
\item Reactivo: actúa promovido por un cambio en el entorno (Guardián de algún tesoro).
\item Proactivo: decide actuar antes de que se produzcan los sucesos (Jefe final de un juego).
\end{itemize}
\item Máquinas de estados finitos: entidad abstracta que está formada por diferentes estados y las transiciones que se producen entre ellos. Estas transiciones están producidas por cambios que se van produciendo en el entorno. Según el estado en se encuentre, se pueden llevar a cabo una serie de acciones.
\item Redes neuronales: están inspiradas en el comportamiento de las neuronas y conexiones del cerebro humano, tratando de crear programas capaces de solucionar problemas difíciles, actuando como haría un humano. Necesitan entrenamiento con muchos ejemplos.
\item Algoritmos evolutivos y Programación genética: Son sistemas muy robustos que resuelven problemas de optimización, donde los individuos más capaces son los que finalmente sobreviven, tras aplicarles una serie de transformaciones.
\end{itemize}

\section{Nuestra aportación}

Nuestro proyecto pretende analizar el rendimiento de los AGs, y determinar si es viable usarlos como mecanismo de generación automática de elementos de un juego sin necesidad de un diseño previo, así como estudiar la calidad de los elementos generados y la dificultad que puede conllevar establecer unos buenos parámetros para estos algoritmos. \par
En la parte de generación de los mapas hemos optado por representar cada individuo mediante un grafo que representa el esqueleto de nuestra mazmorra. Se aplica un algoritmo evolutivo para transformar una de las CCs del grafo hasta obtener una mazmorra satisfactoria.\par
Dada la pequeña cantidad de proyectos y documentación en relación a la generación automática de IAs en videojuegos, nuestro proyecto trata de hacer un análisis sobre la posibilidad de aplicar técnicas evolutivas en este aspecto. De forma análoga al proyecto MADE \citep*{Garcia}, intentaremos automatizar los procesos de desarrollo de elementos principales de un videojuego, centrándonos en analizar aspectos clave, como la calidad de los elementos generados y el tiempo que conlleva generarlos.\par
En este sentido, hay que tener en cuenta la generación de 2 árboles diferentes (patrulla y ataque) y las transiciones entre estados de uno y otro árbol, siendo en cierta manera cada uno de los estados un árbol diferente (exploración y ataque, como comentábamos antes) \ref{fig:3}.\par

\figurahere{Bitmap/3}{width=1\textwidth}{fig:3}%
{Ejemplo de máquina de estados y decisiones}
	
% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
